 Category
has_many :articles
:name - string

Article
belongs_to :category
:category_id - integer
:title - string,
:body, - string
:subtitle, -string
:author - string
:publish_date, -datetime
:image, - string

create models
not using views for api so use resources
rails g resource "model" attritbue:datatype 
--no-test-framework

create relationships with models
add validations
validates_inclusion_of :user, :in => ['user', 'client']

rails db:migrate
rails db:seed

work on controllers
best practice to create
mkdir api mkdir v1
use namespacing
fetch(http:..localhost:3000/api/v1/categories)

routes
namespace routes.rb to match directories 
add inheritance in controllers using Api::V1::controller

add gem 'rack-cors' 
cross-origin-response
allows to make requests
need to uncomment in Gemfile and in config/intializers/cors.rb
put '*' in example in origins or can specify localhost

deleting db
rails db:drop, then recreate db and migrate 
or
model.destroy_all but wont clear db

rails s -p 3000 to change port

work on instance methods for logic in models 

work on controllers
create crud methods and strong params

work on serializer to send over specific info

frontend
-check if api is working by using fetch get requests
componentDidMount(){
    fetch('http://localhost:3000/api/v1/categories', {
      method: 'GET'
    })
    .then(response => response.json())
    .then(data => console.log(data ))
  }
  change App.js into a class not function

  need to set up serializer so we can chain along response data
  ex. console.log(data[0].articles)
  add to gemfile gem 'active_model_serializers'
  rails g serializer model #do each seperately
  it creates serialzer directory and we can add attributes we want to access
  then add in relationships 

  use pry to check as well if htting backend
  gem foreman to run both servers at same time #optional

  start with adding redux first in frontend
  redux is package that needs to be installed
  npm install redux react-redux  redux-thunk react-router-dom --save #do each individually
  you can check if its installing in package.json

  need to setup store in index.js
  #import {createStore} from 'redux'
  async requests
  #import thunk from 'redux-thunk'
  any component we wrap in provider has access to store
  #import { Provider } from 'react-redux'
  to incorporate thunk with store middleware
  #import {createStore, applyMiddleware} from 'redux'

  set up <Provider> <App/> </Provider> in index.js

  create store 
  #let store = createStore(reducer, applyMiddleware(thunk))
  thunk is middleware we are using 
  add in compose
  #import {createStore, applyMiddleware, compose} from 'redux'
  combines middleware into one so we can pass one argument

  use compose enhancers for devtools
  # const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; 
  the compose in here is the equivalent to compose imported from redux so 
  if redux_devtools extension it will use compose that was imported

    need to update store and pass in composeEnhancers that will take in middleware
    #let store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)))

store is where we are storing our data globally
sending an action object to reducer and reducer is responsible 
of taking action object and deciding what we want to update about our current
stroe and reducer will return a new versionn of that store

pass in store in Provider
# <Provider store={store}>

can create store in seperate file and import in if wanted too

in src directory
create a containers, actions, components, reducers folder

make categoryReducer.js in reducers which is responsible
for updating parts of store related to categories

a reducer is a conditional where you define different action types
that will take in state which should be an object and action object 
it is a function
#export default function categoryReducer(state = {categories: []}, action){
#return state
#}

need to import categoryReducer into index.js
 anytime we see dispatch we want action object to be sent to recuder passed in store 
 which will then update value of store
 #let store = createStore(categoryReducer, composeEnhancers(applyMiddleware(thunk)))

work on fetchCategories.js in actions folder
it is a function which we dispatch an action
creates an action object then action object wil be dispatched to reducer
then returns new version of state based on action we sent

need to import connect in app.js
#import {connect} from 'react-redux'
export default connect(mapStateToProps, mapDispatchToProps or directly pass action creator(fetchCategories))

mapStateToProps is way of accessing value in store as props
to see what is alrady in store need to pass it to connect its our way of 
passing our store to a specific component

mapDispatchToProps or {fetchCategories} is way of update store directly from component
gives access to this.props.fetchCategories() 
gives us ability to dispatch new actions to our stroe directly from component

can pass null as first argument in connect if not using mapDispatchToProps

need to import fetchCategories
it will show up in react devtools as a prop

add fetch in action creator in our case actions/fetchCategories.js

thunk returns a function from action creator

if we are not using backend code below is used to add 
# componentDidMount(){
   # this.props.fetchCategories()
 # }
 manually pass action and payload to code above and change fetchCategories to return action
 # app.js in componentDidMount(){} this.props.fetchCategories({type: 'fetch_categories', payload: {name: 'events'}})
 # action/fetchCategories.js export function fetchCategories(action){return action}}
by using connect this dispatches to store doing the code below automatically
#store.dispatch({type: 'fetch_categories', payload: {name: 'events'}})
need to return action
#export default function categoryReducer(state = {categories: []}, action){
#return action.payload
#}

thunk is to make async requests because using a backend
because fetch requests take some time so connect is expecting an immediately
return from action creator so thunk allows us to call dispatch from inside action creator
lets action creator to finish before dispatching

create CategoriesContainer.js in containers directory
a container renders other components and pass them data 
have other functions/callback componentDidMount 
typically a class component because state 

after making class CategoriesContainer component need to export 
then import in App.js

create Category.js and CategoryInput.js in components directory
which will be rendered in CategoryContainer

in CategoryInput make a controlled form use a local state or form data
in local store so it is a class component so it will be exported 
to render in container

Category,js will be a functional component responsible to show all categories
then import both in conatiner 
it should be rendered on screen if evrything is connected correct

need to import connect to container
need to setup mapStateToProps
then need to fetch using componentDidMount using actions/fetchCategories
so need to import fetchCategories as props in connect 
#export default connect(mapStateToProps, {fetchCategories}) (CategoriesContainer)

need to pass in dispatch in fetchCategories 
thunk lets us user this built in dispatch
connects to reducer to update store with fetch info

in our reducer we make a switch statement for action and to get payload from fetch

# export default function categoryReducer(state = {categories: []}, action){
#     switch (action.type) {
#         case 'FETCH_CATEGORIES':
#             return {categories: action.payload}
#             default:
#                 return state
#     }
# }

deconstruct props ({categories})
or just use (props) and props.categories

need to map from props to get access to all categories which is an array when fetching from index

setup categoryInput with a form
make it a controller form by adding a state and value
need onChange handler so form can change value in state

create a handleChange function
and call it with onChange={this.handleChange}
assign key with object notation if have multiple parts of form to setstates

need to add submit
add onSubmit to form tag
create a handlesubmit function pass in event and preventDafault()
new action creator when adding new category
actions/addCategory.js
add dispatch because of thunk
need to import and add {connect} to CategoryInput
pass null since we dont need props then add action creator addCategory
import {addCategory} to CategoryInput
need to pass in this.state in addCategory(this.state)
since it takes in an argument and have access to data
need to set up fetch using POST
use binding.pry in create in backend controller and check params 

want it to be rendered instantly without refreshing
need to use dispatch for new created category
need to ad to case in reducer with ADD_ACCOUNT
using spread operator to get previous 
in handleSubmit user this.setState to clear out form

create cateogy component
pass in props to have access to create show pages

need to setup router
can use in app or index/conatiner
import {BrowserRouter as Router} from 'react-router-dom'
had to downgrade react router dom to v5
set up route in container after setting up BrowserRouter in index.js
use exact path and render when passing in props if mapping in a nother component
set up nested route in container or path will look like a nested route
give a router {...routerProps} when using render
need to user ternary operator because category isnt set yet
create Link in categories so no params error
use Switch to help render one path at a time and new has to be first because of :id/dynamicroute

make Article Container
set up like we setup category
pass in props through container so article can have access 
need to add in a check  before mapping over props articles beacuse it needs to know about props.articles && 

add article
delete article 
using action and reducer 

